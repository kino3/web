<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" href="doc-styles.css" type="text/css"/>
<title>Movable Typeユーザー・マニュアル: プラグインの書き方</title>
</head>

<body>
<h1 id="__index__">Movable Typeユーザー・マニュアル: プラグインの書き方</h1>
<p><a href="mtmanual.html">&laquo; 目次</a></p>
<ul>
	<li><a href="#writing_a_plugin">プラグインの書き方</a>
	<ul>
		<li><a href="#overview">概要</a></li>
		<li><a href="#plugin_class">MT::Pluginクラス</a>
		<ul>
			<li><a href="#more_than_one_way_to_do_it">1つ以上ある方法</a></li>
		</ul>
		</li>
		<li><a href="#adding_a_plugin_to_the_interface">インタフェースへのプラグインの追加</a></li>
		<li><a href="#adding_tags">タグの追加</a>
		<ul>
			<li><a href="#template_context01">MT::Template::Context->add_container_tag($name, \&amp;subroutine)</a></li>
			<li><a href="#template_context02">MT::Template::Context->add_conditional_tag($name, $condition)</a></li>
		</ul>
		</li>
		<li><a href="#postprocessing_tag_output">処理後のタグの出力</a></li>
		<li><a href="#plugin_callbacks">プラグインのコールバック</a>
		<ul>
			<li><a href="#callback_priorities">コールバックの優先順位</a></li>
			<li><a href="#error_handling">エラーの取り扱い</a></li>
		</ul>
		</li>
		<li><a href="#text_filters">テキスト･フィルター</a>
		<ul>
			<li><a href="#adding_a_text_filter">テキスト･フィルターの追加</a></li>
		</ul>
		</li>
		<li><a href="#adding_an_action_to_a_movable_type_application_page">Movable Typeのアプリケーション･ページへのアクションの追加</a></li>
	</ul>
	</li>
</ul>
<hr />

<h2><a name="writing_a_plugin"></a>プラグインの書き方</h2>
<h2><a name="overview"></a>概要</h2>
<p>プラグインは、Movable Typeのパブリッシング･プラットフォームを、数ある方法のひとつで拡張するソフトウエアです。 プラグインは、Movable Typeの新しいテンプレート･タグを作成できます。また、既存のタグに「グローバル･フィルターと呼ばれる」アトリビュート(属性)を足すこともできます。さらにエントリーのテキストを構築中に処理できます。また、コールバックをインストールして、データベースのイベント発生時にオブジェクトを処理できます。 プラグイン</p>

<h2><a name="plugin_class"></a>MT::Pluginクラス</h2>
<p>Movable Type 3.0に新しく搭載されたMT::Pluginクラスは、ユーザーと対話するプラグインのすべてのデータをカプセル化します。 これによってユーザーは、インストールされたプラグインをGUIで操作できるようになりました。</p>
<p>どんなプラグインをインストールしているか常にわかるように、どのプラグインにもMT::Pluginオブジェクトを登録することを推奨します。 しかし、プラグインがこのように登録できなくても、プラグインの他の機能は動作するはずです。</p>
<p>とりわけ、MT::Pluginは、プラグインの名前とバージョン、短い説明、およびドキュメントと設定インタフェースへのリンク情報を保持します。 この情報を供給するために、プラグインが採用できる方法は2種類以上あります。</p>

<h3><a name="more_than_one_way_to_do_it"></a>1つ以上ある方法</h3>
<p>まず、プラグインに、MT::Pluginのサブクラスを記述して、methods name()、description()、<em> doc_link() </em> 、およびconfig_link()を実装し、該当するデータをそれぞれに返す方法があります。</p>
<p>また、MT::Pluginのインスタンスを作成し、そのメソッドを使って該当するフィールドを設定することもできます。</p>

<pre>
$plugin = new MT::Plugin();
$plugin->name("Arthur Dent's Duplicator Plugin, v.0.45");
$plugin->description("Duplicates weblog posts with a minimum of fuss.");
</pre>

<h2><a name="adding_a_plugin_to_the_interface"></a>インタフェースへのプラグインの追加</h2>
<p>MT::Pluginオブジェクトが作成されると、そのプラグインはMovable Typeのメソッド、<em> add_plugin_slug($plugin) </em> を呼び出して、Movable Typeのインタフェースにおける足場を確立します。 このメソッドは、「メインメニュー」にスロットを作成します。そこには、プラグインの名前と説明が表示され、設定インタフェースとドキュメントのページへのリンクが含まれます。</p>
<p>プラグイン･ファイルには、<em> pl </em>  の拡張子が付くはずです(プラグインの検索時には、他の拡張子を持つファイルは無視されます)。 設定ページには通常<em> cgi </em> の拡張子が付きます。これはウェブサーバーがそのページをCGIプログラムとして実行するために必要です。 ただしウェブサーバーによっては、CGIプログラムに<em> pl </em> の拡張子を採用しないとCGIプログラムが機能しないものもあります。 したがって、ファイルの拡張子を除いた名前の部分は、独自の名称にしておく方がよいでしょう。</p>

<h2><a name="adding_tags"></a>タグの追加</h2>
<p>Movable Typeにはさまざまなテンプレート･タグが搭載されているので、プラグインの作成者やデザイナーは、それらを使ってカスタマイズされた外見と使い勝手を持つサイトを作り上げることができます。</p>
<p>プラグインの作成者は、新しいテンプレート･タグを加えてコンピューター処理できる文字列を生成することで、システムを拡張できます。 タグは、<em> MT::Template::Context </em> のadd_tagおよびadd_conditional_tagメソッドを使って追加します。</p>

<pre>
MT::Template::Context->add_tag($name, \&amp;subroutine)
</pre>

<p><em> add_tag </em> はシステムに単純な「変数タグ」を登録します。 このタグの一例は<em> &lt;$MTEntryTitle$> </em> です。</p>
<p><em> $name </em> は接頭語、<em> MT </em> を省いたタグ名で、<em> \&amp;subroutine </em> はサブルーチン(匿名または名前付き)へのリファレンスです。 <em> \&amp;subroutine </em> はエラー(「<a href="#error handling">エラーの取り扱い</a>」を参照)、または定義済みのスカラー値(数値または文字列)を返します。<em> undef </em> を返すとエラーとして扱われるので、その代わりに常時、空の文字列を返します。</p>
<p>例：</p>
<pre>MT::Template::Context->add_tag(ServerUptime => sub { `uptime` });
</pre><p>このタグは、<em> &lt;$MTServerUptime$> </em> としてテンプレートに使います。</p>
<p>このサブルーチン･リファレンスは2つの引数を渡されます。 ひとつはテンプレートといっしょに構築する<em> MT::Template::Context </em> オブジェクトで、もうひとつはテンプレート･タグを介して渡される引数を含むハッシュへのリファレンスです。 たとえば、タグの<em> &lt;$MTFooBar$> </em> が以下のように呼び出されたときは、</p>

<pre>
&lt;$MTFooBar baz="1" quux="2"$>
</pre>

<p>このタグに登録されたサブルーチンへの2番目の引数は、以下のようになります。</p>
<pre>
{
    'quux' => 2,
    'bar' => 1
};
</pre>

<h3><a name="template_context01"></a>MT::Template::Context->add_container_tag($name, \&amp;subroutine)</h3>
<p>「コンテナ･タグ」をテンプレート･システムに登録します。 コンテナ･タグは通常、ループまたは条件文を表すのに使います。 実際には<em> add_container_tag </em> をループに使い、<em> add_conditional_tag </em> を条件文に使います。こうしておくと、ほとんどの条件文のタグ･ハンドラーが同じ構造をしているため、後の面倒な作業をほとんど処理してくれます。</p>
<p><em> $name </em> は接頭語、<em> MT </em> を省いたタグ名で、<em> \&amp;subroutine </em> はサブルーチン(匿名または名前付き)へのリファレンスです。 <em> \&amp;subroutine </em> はエラー(「<a href="#error handling">エラーの取り扱い</a>」を参照)、または定義済みのスカラー値(数値または文字列)を返します。<em> undef </em> を返すとエラーとして扱われるので、その代わりに常時、空の文字列を返します。</p>
<p>このサブルーチン･レファレンスは2つの引数を渡されます。 ひとつはテンプレートといっしょに構築する<em> MT::Template::Context </em> オブジェクトで、もうひとつはテンプレート･タグに渡される引数を含むハッシュへのリファレンスです。</p>
<p>コンテナ･タグは一般にループを表すので、サブルーチン内にループ構造を使い一連のアイテムをループさせて、各アイテムのコンテナ内に使うテンプレート･タグを構築する必要があります。 これらの内部に使うテンプレート･タグは、<strong>すでにトークンのリストへコンパイルされています</strong>。 したがって後は、<em> MT::Builder </em> オブジェクトを使って、このトークンのリストをスカラー文字列に構築し、その文字列を出力値に加えるだけです。 トークンのリストは<em> $ctx->stash('tokens') </em> にあり、<em> MT::Builder </em> オブジェクトは<em> $ctx->stash('builder') </em> にあります。</p>
<p>たとえば、タグの<em> &lt;MTLoop> </em> が以下のように使われたときは、</p>

<pre>
&lt;MTLoop>
The value of I is: &lt;$MTLoopIValue$>
&lt;/MTLoop>
</pre>

<p>以下は、このタグセットの実装例です。</p>

<pre>
MT::Template::Context->add_container_tag(Loop => sub {
    my $ctx = shift;
    my $res = '';
    my $builder = $ctx->stash('builder');
    my $tokens = $ctx->stash('tokens');
    for my $i (1..5) {
        $ctx->stash('i_value', $i);
        defined(my $out = $builder->build($ctx, $tokens))
            or return $ctx->error($builder->errstr);
        $res .= $out;
    }
    $res;
});
MT::Template::Context->add_tag(LoopIValue => sub {
    my $ctx = shift;
    $ctx->stash('i_value');
});
</pre>

<p><em> &lt;$MTLoopIValue$> </em> は単純な変数タグです。 <em> &lt;MTLoop> </em> はコンテナ･タグとして登録され、1から5までをループし、各番号に付き、<em> &lt;MTLoop> </em> と<em> &lt;/MTLoop> </em> の間でトークンのリストを構築します。 これは、<em> $builder->build </em> の起動ごとに返るエラー値をチェックします。</p>

<p>上のタグは、以下を表示します。</p>

<pre>
The value of I is: 1
The value of I is: 2
The value of I is: 3
The value of I is: 4
The value of I is: 5
</pre>

<h3><a name="template_context02"></a>MT::Template::Context->add_conditional_tag($name, $condition)</h3>
<p>「コンテナ･タグ」をテンプレート･システムに登録します。</p>
<p>条件タグは実際にはコンテナ･タグのひとつですが、条件タグを書く作業を簡単にするため、<em> add_conditional_tag </em> メソッドを使うことができます。 <em> $name </em> は接頭語、<em> MT </em> を省いたタグ名で、<em> $condition </em> は、条件が合致するかどうかで真か偽の値を返すサブルーチンへのリファレンスです。 条件が合致すると、タグのブロックと条件タグ内にあるマークアップが実行され表示されます。合致しないと、無視されます。</p>
<p>たとえば、以下のコードは2つの条件タグを登録します。</p>

<pre>
MT::Template::Context->add_conditional_tag(IfYes => sub { 1 });
MT::Template::Context->add_conditional_tag(IfNo => sub { 0 });
</pre>

<p><em> &lt;MTIfYes> </em> は常に1を返すので、常にその内容は表示されます。<em> &lt;MTIfNo> </em> は常に0を返すので、その内容はまったく表示されません。 したがってこれらのタグを以下のように使った場合は、</p>

<pre>
&lt;MTIfYes>Yes, this appears.&lt;/MTIfYes>
&lt;MTIfNo>No, this doesn't appear.&lt;/MTIfNo>
</pre>

<p>"Yes, this appears.”だけが表示されます。</p>
<p>もっとおもしろい例は、<em> &lt;MTEntryIfTitle> </em> のタグを加えて、エントリー･コンテキストに使うことです。すると、エントリーにタイトルがある場合はその内容が表示されます。</p>

<pre>
MT::Template::Context->add_conditional_tag(EntryIfTitle => sub {
    my $e = $_[0]->stash('entry') or return;
    defined($e->title) &amp;&amp; $e->title ne '';
});
</pre>

<p>このタグを使った一例です。</p>

<pre>
&lt;MTEntries>
&lt;MTEntryIfTitle>
This entry has a title: &lt;$MTEntryTitle$>
&lt;/MTEntryIfTitle>
&lt;/MTEntries>
</pre>

<h2><a name="postprocessing_tag_output"></a>処理後のタグの出力</h2>
<p>新しいタグを追加するほかに、プラグインはどんなタグにも適用できるアトリビュート(属性)を追加できます。 アトリビュートに関連したコードは呼び出されると、タグの出力を変換します。</p>

<pre>
MT::Template::Context->add_global_filter($name, \&amp;subroutine)
</pre>

<p>$nameはたとえば、”encode_html”などのタグ名を表します。 encode_html=valueのアトリビュートを含むMT(Movable Type)テンプレート･タグはどれも、与えられたサブルーチンを起動します。</p>
<p>コード･リファレンスの\&amp;subroutineは以下のように呼び出されます。</p>

<pre>
$string = &amp;subroutine($string, $attribute_value, $context)
</pre>

<p>$stringパラメータは、変換するテキストを示します。 $attribute_valueは、このコードの起動時にアトリビュートに与えられる値です。</p>

<pre>
&lt;MTEntryTitle encode_html=1>
</pre>

<p><em> &amp;subroutine </em> は、<em> $attribute_value </em> が<em> 1 </em> に設定されると起動します。 サブルーチンの最後の引数である$contextは、タグが使われたコンテキストについての情報を含む<em> MT::Template::Context </em> オブジェクトへのリファレンスです。</p>

<h2><a name="plugin_callbacks"></a>プラグインのコールバック</h2>
<p>ほとんどの<em> MT::Object </em> の動作は、プラグインへのコールバックを引き起こします。 この動作による特筆すべき機能として、データベースの記録が変更すると通知が受けられること、およびデータベースに流れているデータの前処理と後処理ができることが挙げられます。</p>
<p>コールバックを追加するには、以下のように<em> MT::Object </em> サブクラスの<em> add_callback </em> メソッドを起動します。</p>

<pre>
MT::Foo->add_callback("pre_save", &lt;priority>,
                      &lt;plugin object>, \&amp;callback_function);
</pre>
<p>最初の引数はフックポイントの名前です。 <em> MT::Object </em> サブクラスは、以下の各操作における<em> pre_ </em> および<em> post_ </em> フックポイントを持っています。</p>

<pre>
load
save
remove
remove_all
(load_iter操作はloadコールバックを呼び出します)
</pre>

<p>2番目の引数である &lt;priority>は、コールバックを呼び出す際の相対的な優先順位を示します。 通常、値は1から10の間に設定されます。 優先順位1のコールバックは優先順位2のコールバックより前に呼び出され、２は3より前に呼び出され、以下同様に続きます。</p>
<p>最初または最後に実行する必要があることを知っているプラグインは、それぞれ優先順位0または11を使用できます。 優先順位0のコールバックは、他のコールバックよりも先に実行します。そして2つのコールバックが同じ値を使おうとすると、エラーが発生します。 優先順位11もまた排他的で、そのコールバックは最後に実行します。</p>
<p>どのコールバックの優先順位が特別かを覚えておくにはどうしたよいでしょうか。 たとえば、ギターのアンプには1から10まで音量を調節できるつまみがあります。 しかし、私達のアンプは、一部のロックスターのアンプと同様、11の音量まで上がります。 優先順位11のコールバックは、「最も音量の大きな」最も強力なコールバックです。これは、pre-opコールバックの場合、オブジェクトがデータベースに保存される直前に呼び出され、post-opコールバックの場合、オブジェクトが返される直前に呼び出されるからです。 優先順位0のコールバックは、「最も音量の低い」コールバックで、それに続くコールバックによって完全に圧倒されます。 優先順位0は、あなたのプラグインを他のプラグインとうまく機能させたいと願うならば、あなたのプラグインにとってよい選択になるかもしれません。 正しい優先順位を指定できるかどうかの鍵は、あなたのプラグインが他のプラグインとどのような関係にあるかを考え、あなたのプラグインをユーザーが最大限利用できるよう、経験に基づいて優先順位を調節していくことに尽きます。</p>
<p><em> &lt;plugin object> </em> は、プラグインについての情報を提供するタイプ<em> MT::Plugin </em> のオブジェクトです。 これは、エラー･メッセージにプラグインの名前を含めるために使います。</p>
<p><em> &lt;callback function> </em> は呼び出されるサブルーチンのコード･リファレンスです。 この関数の引数は、操作によって異なりますが(詳細は「<em> MT::Callback </em> 」を参照)、どのケースも最初のパラメータは<em> MT::Callback </em> オブジェクトそのものです。</p>

<pre>
sub my_callback {
    my ($cb, ...) = @_;
    if ( &lt;error condition> ) {
        return $cb->error("Error message");
    }
}
</pre>

<p>正確にはコールバックの戻り値は無視されます。 <em> MT::Callback </em> オブジェクト(この場合は<em> $cb </em> )の<em> error() </em> メソッドを呼び出すと、Movable Typeのアクティビティ･ログにエラー･メッセージが生成します。</p>

<p>別のエラーの扱い方は<em> die </em> を呼び出す方法です。 コールバックがdieすると、<em> MT </em> はアクティビティ･ログにエラーを警告しますが、引き続き<em> MT::Object </em> の動作を処理します。 したがってそのほかのコールバックは依然として実行され、データベースの操作も続いています。</p>

<h3><a name="callback_priorities"></a>コールバックの優先順位</h3>
<p>プラグインの作成者は、コールバックを登録するたびに、そのコールバックに優先順位を指定し、プラグインが実行する順序を管理します。 優先順位は1から10の間に設定されます。優先順位1のコールバックはどのイベントよりも先に実行され、優先順位10のコールバックはどのイベントよりも後に実行されます。</p>
<p>プラグインを書くときには、それが他のプラグインとどのように関係するかを考慮します。 プラグインが比較的ゆるやかなデータ変換しか要しない場合もあることでしょう。また、プラグインが他のプラグインでデータが使えない状態になるほど、動的な場合もあることでしょう。 より動的なプラグインを使う場合は、その'save'コールバックに高い優先順位を設定してください。</p>

<h3><a name="error_handling"></a>エラーの取り扱い</h3>
<p>プラグインのコールバックがdieしても、Movable Typeは引き続き実行し他のコールバックを呼び出します。</p>
<p>ただし、1つのコールバックが別の返ってきたコールバックに依存している場合、コールバックの1つは、何らかの理由で実行されないことがあります。 たとえば、<em> load() </em> に対し実行するコールバックと<em> save() </em> に対し実行するコールバックの、2つの対称的なコールバックがある場合、saveのコールバックに失敗すると、データベースのデータはloadのコールバックが必要とする形態で得られないこともあります。</p>

<h2><a name="text_filters"></a>テキスト･フィルター</h2>
<p>Movable Typeは、エントリーをフォーマット･プロパティを使って作成する上で役立つ、拡張可能なテキスト･フィルターを種々用意しています。 HTMLでエントリーを記入する代わりに、テキスト･フィルターを選ぶことができます。テキスト･フィルターは、記号の一部を洗練されたフォーマット･コマンドに置き換え、エントリー･テキストを変換することができます。 テキスト･フィルターは、エントリー編集画面のポップアップ･メニューに表示されるので、エントリーごとに選択できます。</p>

<h3><a name="adding_a_text_filter"></a>テキスト･フィルターの追加</h3>
<p>テキスト･フィルターは<em> MT->add_text_filter() </em> を呼び出して、以下のように追加します。</p>
<pre>
MT->add_text_filter($key, {label => $label, 
                           on_format => &lt;executable code>});
</pre>
<p><em> $label </em> は、人間が読めるテキストでフィルターをユーザーに特定します。このテキストはエントリー編集画面のポップアップ･メニューに表示されます。 <em> $key </em> は、HTMLの<em> name </em> アトリビュートに使われるIDで、メニューのフィルターは<em> $key </em> の値によってアルファべット順に並び替えられます。</p>
<p><em> on_format </em> キーの値に渡される値はコード･リファレンスです。 このコード･リファレンスは呼び出されると、エントリー･テキストを表示する前に変換します。</p>
<p>このコード･リファレンスは、エントリー編集画面を除き、エントリーが表示されるところであればどこでも呼び出されます。 たとえば、エントリー確認(プレビュー)、<em> &lt;MTEntryBody> </em> タグの結果、トラックバックping、ニュースフィードなどです。</p>

<h2><a name="adding_an_action_to_a_movable_type_application_page"></a>Movable Typeのアプリケーション･ページへのアクションの追加</h2>
<p>Movable Typeのアプリケーション･インタフェースのページの一部を使うと、あるタイプのオブジェクトを一覧表示したり、オブジェクトを編集したりすることが可能になります。 こうしたページの多くは、ユーザーがオブジェクトに対しアクションを追加する形式で自然な拡張を許可しています。</p>
<p>これらの1ページにアクションを追加するには、<em> MT </em> クラスの<em> add_plugin_action </em> メソッドを呼び出します。</p>
<pre>
MT->add_plugin_action('entry', $link,
                      'Add one xyzzy monster to this entry');
</pre>
<p>上記の<em> entry </em> はリンクが表示されるページを示します。 単純なオブジェクト･タイプを渡すと、そのタイプのオブジェクトを「編集」するページにアクションのリンクが表示されるはずです。 そのほか使用可能な値には、<em> comment </em> 、<em> category </em> 、<em> template </em> 、<em> author </em> などがあります。</p>
<p>さらに、以下の値のいずれかを最初の引数に渡すと、オブジェクトのリストの1つにアクション･リンクを張ることができます： <em> list_comments </em> 、<em> list_commenters </em> 、<em> list_entries </em> </p>

<hr />

<span class="copyright">Copyright &copy; 2001-2005 Six Apart, Ltd. All Rights Reserved.</span>
</body>
</html>
